/* 中断服务程序 */
#include "interrupt.h"
unsigned char j = 1;
/* spwm正弦表 */
unsigned int table[]={250,257,264,271,278,285,292,299,305,312,319,326,332,339,345,352,
358,364,370,376,382,387,393,398,404,409,414,418,423,427,432,436,
439,443,447,450,453,456,459,461,463,466,467,469,471,472,473,474,
474,474,475,474,474,474,473,472,471,469,467,466,463,461,459,456,
453,450,447,443,439,436,432,427,423,418,414,409,404,398,393,387,
382,376,370,364,358,352,345,339,332,326,319,312,305,299,292,285,
278,271,264,257,250,242,235,228,221,214,207,200,194,187,180,173,
167,160,154,147,141,135,129,123,117,112,106,101,95,90,85,81,
76,72,67,63,60,56,52,49,46,43,40,38,36,33,32,30,
28,27,26,25,25,25,25,25,25,25,26,27,28,30,32,33,
36,38,40,43,46,49,52,56,60,63,67,72,76,81,85,90,
95,101,106,112,117,123,129,135,141,147,154,160,167,173,180,187,
194,200,207,214,221,228,235,242};
/*******外部中断0中断服务程序***********/
ISR(INT0_vect)
{
	PORTD^=_BV(LED3);
}

/*******TIMER0中断服务程序（秒表功能）***********/
ISR(TIMER0_OVF_vect)
{
	/* 每250ms进入中断， */
	TCNT0 = 6; //重装载计数值
	Cnt++;
	if(Cnt > 3)//num 每隔 250ms*4=1s 更新一次
	{
		led2_toggle();
		num++;
		Cnt = 0;
	}
	if(num > 60 )
	{
		num = 0;
	}
}

/*******TIMER1中断服务程序（PWM功能）***********/
/* 1k，25%占空比相位修正PWM */
ISR(TIMER1_COMPA_vect)
{
	OCR1A = 125; //重装载计数值
	ICR1  = 500;
	//PORTB ^= (1<<PB1);//PWM波形输出到端口
}

/* SPWM,由PWM的频率1k可知，SPWM的频率为 1K/N ，N为一周期的点数，这里取200 调制度0.9*/
ISR(TIMER1_COMPB_vect)
{
	ICR1  = 500;
	OCR1B = table[Cnt2]; 
	if( j%2 == 0)
	{
		Cnt2++;
		OCR1B = table[Cnt2]; //重装载计数值
	}
	if( Cnt2 >= 200 )
	{
		Cnt2 = 0;
		j = 0;
	}
	j++;

	//Cnt2++;
	//if(Cnt2 > 1000)
	//{
	//	Cnt2 = 0;
	//}
	//PORTB ^= (1<<PB2);//SPWM波形输出到端口
}

/*******ADC中断服务程序***********/
ISR(ADC_vect)
{
	//delay_1ms(1);
	//temp=ADCH;//读取转化的数据
	temp = ADCL>>6;
	temp2 = ADCH;
	temp2 <<= 2;
	temp += temp2;   //10bit
	ADCSRA|=0X40;//重启ADC，设置ADCSRA的ADATA和连续转换模式时不用
}
